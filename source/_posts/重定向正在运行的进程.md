---
title: 重定向正在运行的进程
date: 2016-08-10 10:45:42
tags:
- gdb
- Linux
---

主要利用gdb
<!--more-->

# 参考
[Capture input/output of a process with gdb][1]
[gdb open][2]
[文件操作中的FLAG（O_RDONLY，O_WRONLY ）的值][3]

---

# 需求
我老是会在执行了命令以后才发现没在开头加`nohup`😂, 之前一直束手无策啊, 就算disown以后还是会在当前的shell里输出实在是太尴尬了呀

# 思路
- gdb可以指定一个进程来attach, 可以通过`gdb -p <PID>`或者在进入了gdb以后`attach <PID>`来做到
- gdb里可以用call来进行系统调用
- Linux提供`close`和`close`系统调用, 可以打开或者关闭文件
- stdin, stdout, stderr分别对应一个进程的0, 1, 2号文件描述符
- 那我就可以先挂起一个进程, 然后在gdb里重定向它的io了呀

# 实现
## 模拟方法
- 可以用一个不带参数的`cat`或者`tail -f <file>`来模拟
- 我们这次模拟重定向一个stdin

## 步骤
- `cat`: 此时阻塞, 回显
- `touch hehe`: 创建一个文件, 假设我们现在在/root下
- `ctrl+z`: 挂起cat进程
- `jobs -l`: 查看jobs的PID, 假设是17712
- `gdb -p 17712`: 另一个gdb附着于进程上
- `call close(0)`: 关闭stdin
- `call open("/root/hehe", 2, 0)`: 将stdin重定向为hehe
- `detach`: 让gdb脱离进程
- `q`: 退出gdb
- `lsof -p 17712`: 查看cat进程的打开文件, 会发现0已经变成hehe了
- `fg 1`: 让cat在前台运行
- 再打开一个shell会话, 然后`echo hehe > hehe`: 会发现cat有输出了, stdin重定向成功

# 其他问题
- 我怎么知道`O_RDWR`的值是多少呢
    - 可以写一个简单的c程序来获取, 这些宏定义都在fcntl.h里面
    ```
    #include <stdio.h>
    #include <fcntl.h>
    void main(void)
    {
        printf("O_ACCMODE       %08x\n",  O_ACCMODE               ) ; 
        printf("O_RDONLY        %08x\n",  O_RDONLY                ) ; 
        printf("O_WRONLY        %08x\n",  O_WRONLY                ) ; 
        printf("O_RDWR          %08x\n",  O_RDWR                  ) ; 
        printf("O_CREAT         %08x\n",  O_CREAT                 ) ; 
        printf("O_EXCL          %08x\n",  O_EXCL                  ) ; 
        printf("O_NOCTTY        %08x\n",  O_NOCTTY                ) ; 
        printf("O_TRUNC         %08x\n",  O_TRUNC                 ) ; 
        printf("O_APPEND        %08x\n",  O_APPEND                ) ; 
        printf("O_NONBLOCK      %08x\n",  O_NONBLOCK              ) ; 
        printf("O_DSYNC         %08x\n",  O_DSYNC                 ) ; 
        printf("FASYNC          %08x\n",  FASYNC                  ) ; 
        printf("O_NOFOLLOW      %08x\n",  O_NOFOLLOW              ) ; 
    }
    /*
    O_ACCMODE       00000003
    O_RDONLY        00000000
    O_WRONLY        00000001
    O_RDWR          00000002
    O_CREAT         00000040
    O_EXCL          00000080
    O_NOCTTY        00000100
    O_TRUNC         00000200
    O_APPEND        00000400
    O_NONBLOCK      00000800
    O_DSYNC         00001000
    FASYNC          00002000
    O_NOFOLLOW      00020000
    */
    ```
- 这个方法的其他应用?
    - 如果我因为操作不当彻底丢失了一个进程的控制却又不想杀掉它的时候可以这样弄
    - 进入gdb, 附着在指定进程上
    ```
    $ tty
    /dev/pts/2
    $ gdb -p PID
    (gdb) call close(0)
    (gdb) call close(1)
    (gdb) call close(2)
    (gdb) call open("/dev/pts/2", 2, 0)
    (gdb) call dup2(0, 1)
    (gdb) call dup2(0, 2)
    (gdb) detach
    (gdb) q
    ```
    - 这样就恢复了对这个进程的控制

[1]:http://gcolpart.evolix.net/blog21/capture-inputoutput-of-a-process-with-gdb/
[2]:https://sourceware.org/gdb/onlinedocs/gdb/open.html
[3]:http://www.fx114.net/qa-186-148723.aspx


