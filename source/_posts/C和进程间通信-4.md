---
title: C和进程间通信(4)-信号
tags:
  - Linux
  - C/C++
date: 2016-08-15 18:33:14
---

信号
<!--more-->

# 参考
[Linux环境进程间通信(二): 信号(上)][1]

---

# 发送信号
## int kill(pid_t pid, int signo)
## int raise(int signo)
## int sigqueue(pid_t pid, int sig, const union sigval val)
```
union sigval {
    int     sival_int;
    void   *sival_ptr;
};
```
## unsigned int alarm(unsigned int seconds)
## int setitimer(int which, const struct itimerval \*value, struct itimerval \*ovalue)
## void abort(void)

---

# 安装信号
## void (\*signal(int signum, void (\*handler))(int))(int)
## int sigaction(int signum, const struct sigaction \*act, struct sigaction \*oact)
```
struct sigaction {
    union __sigaction_u __sigaction_u; /* signal handler */
    sigset_t sa_mask; /* signal mask to apply */
    int     sa_flags; /* signal flags */
};

union __sigaction_u {
    void (*__sa_handler)(int);
    void (*__sa_sigaction)(int, siginfo_t *, void *);
};

/* used for convenience */
#define sa_handler      __sigaction_u.__sa_handler 
#define sa_sigaction    __sigaction_u.__sa_sigaction

int 
sigaction(int sig, const struct sigaction *restrict act, 
    struct sigacion *restrict oact);
```
感觉把这些列出来好像就差不多能懂了
## sa_flags
- SA_NOCLDSTOP
    如果这个选项在为SIGCHLD信号安装handler时设定, 那么子进程停止时不会产生SIGCHLD信号, 只有在退出的时候才会产生SIGCHLD信号.
- SA_NOCLDWAIT
    如果这个选项在为SIGCHLD信号安装handler时设定, 那么系统不会在该进程子进程退出的时候创建僵尸进程. 
- SA_ONSTACK
    可以选择让信号处理函数运行于一个信号无关的栈上, 而不是主进程的栈上.
- SA_NODEFER
    当前sigaction设置的信号将不会被阻塞, 也就是说掩码里不会加上当前信号本身
- SA_RESETHAND
    当信号被传送给进程后, 该信号的处理方式会被重置
- SA_RESTART
    设置声明如果一些特定的系统调用被信号所打断, 那该调用会重新启动.
- SA_SIGINFO
    会使用sa_sigaction来传递信息, 当使用SIG_DFL或者SIG_IGN来处理信号时候, 这一位必须关闭置0.
## sa_mask
当一个新的信号被进程所接收的时候, 会按照sigaction里面配置的那样, 使用临时的sa_mask, 当信号处理完毕后, 又会恢复到原来的掩码. 这个临时的掩码由这个信号本身, 原本的掩码, sigaction设置的掩码共同构成.

---

# 信号集及其操作
## int sigemptyset(sigset_t \*set);
## int sigfillset(sigset_t \*set);
## int sigaddset(sigset_t \*set, int signum);
## int sigdelset(sigset_t \*set, int signum);
## int sigismember(const sigset_t \*set, int signum);

---

# 信号的阻塞与未决
## 注意事项
当多个同样的非实时信号(不可靠信号)到达并且阻塞时, 如果使用sigpending来查看阻塞的信号, 会发现只有一个. 而实时信号是可靠的. 非可靠信号是前面32个, 后面32个是可靠信号. 非实时信号都不可靠, 实时信号都可靠
## int sigprocmask(int how, const sigset_t \*set, sigset_t \*oldset)
## int sigpending(sigset_t \*set)
## int sigsuspend(const sigset_t \*mask)

---

# SIGCHLD产生条件
- 子进程终止
- 子进程接收到SIGSTOP停止
- 子进程在停止状态, 收到SIGCONT唤醒

---

# 信号声明周期与排队原理
## 创建
## 注册
```
struct sigpending {
    struct sigqueue \*head, \*tail; //不过好像并不是这个样子的链表, 而是一个通用结点结构
    sigset_t signal;
}pending;

struct sigqueue {
    struct sigqueue *next;
    siginfo_t info;
}
```
注意, 可靠信号和不可靠信号的注册过程在此是不同的, 不可靠信号会首先检查链表中是否存在相同信号, 而可靠信号不会, 而是直接往上挂, 因此导致了信号的"可靠与不可靠"
## 注销
## 终止

---

# 异步信号安全的接口
```
The following functions are either reentrant or not interruptible by sig-
nals and are async-signal safe.  Therefore applications may invoke them,
without restriction, from signal-catching functions:

Base Interfaces:

_exit(), access(), alarm(), cfgetispeed(), cfgetospeed(), cfsetispeed(),
cfsetospeed(), chdir(), chmod(), chown(), close(), creat(), dup(),
dup2(), execle(), execve(), fcntl(), fork(), fpathconf(), fstat(),
fsync(), getegid(), geteuid(), getgid(), getgroups(), getpgrp(),
getpid(), getppid(), getuid(), kill(), link(), lseek(), mkdir(),
mkfifo(), open(), pathconf(), pause(), pipe(), raise(), read(), rename(),
rmdir(), setgid(), setpgid(), setsid(), setuid(), sigaction(),
sigaddset(), sigdelset(), sigemptyset(), sigfillset(), sigismember(),
signal(), sigpending(), sigprocmask(), sigsuspend(), sleep(), stat(),
sysconf(), tcdrain(), tcflow(), tcflush(), tcgetattr(), tcgetpgrp(),
tcsendbreak(), tcsetattr(), tcsetpgrp(), time(), times(), umask(),
uname(), unlink(), utime(), wait(), waitpid(), write().

Realtime Interfaces:

aio_error(), sigpause(), aio_return(), aio_suspend(), sem_post(),
sigset().

ANSI C Interfaces:

strcpy(), strcat(), strncpy(), strncat(), and perhaps some others.

Extension Interfaces:

strlcpy(), strlcat().
```
以上来自man

[1]:http://www.ibm.com/developerworks/cn/linux/l-ipc/part2/index1.html


