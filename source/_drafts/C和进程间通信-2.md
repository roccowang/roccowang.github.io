---
title: C和进程间通信(2)-匿名管道
date: 2016-08-13 00:54:02
tags:
- Linux
- C/C++
---

管道
<!--more-->

# 参考
[Linux环境进程间通信(一)][1]
[linux系统编程之管道（二）：管道读写规则][2]
[Atomicity of Pipe I/O][3]

---

# 相关知识
- `kill -l`查看当前系统支持的信号们
- 管道是半双工的, 如果要实现全双工通信, 则需要开两个管道
- 管道默认是阻塞的, 可以通过fcntl函数来使管道成为非阻塞的
- 管道本质上是一个由内核管理的一个缓冲区
- 读写操作在数量小于PIPE_BUF时都是原子的, 大于时就不是了(见[这里][3]), 关于写操作的原子性见下一条
- 原子性和试图写入的大小, 阻塞性(O_NONBLOCK)的关系, 注意:PIPE_BUF和管道的容量不是一个东西
    - O_NONBLOCK disabled
        - n <= PIPE_BUF
            此时会保证原子性, 如果管道空间不够则会阻塞直到空间足够
        - n > PIPE_BUF
            此时不会保证原子性, 写入的字符可能会被其他进程打断, 写入时如果管道满则阻塞等待
    - O_NONBLOCK enabled
        - n <= PIPE_BUF
            此时会保证原子性, 如果缓冲空间不够则会立刻出错(EAGAIN)返回
        - n > PIPE_BUF
            此时不会保证原子性, 如果缓冲区域满则立刻出错(EAGAIN)返回, 否则会试着写, 直到满再出错(EAGAIN)退出, 因此需要确认写了多少字节, 写入的字符也可能会被其他进程打断
- 管道为空时
    - O_NONBLOCK disabled
        read会阻塞, 直到非空
    - O_NONBLOCK enabled
        read出错(EAGAIN)返回-1
- 管道为满
    - O_NONBLOCK disabled
        write阻塞, 直到非满
    - O_NONBLOCK enabled
        write出错(EAGAIN)返回-1
- 如果所有人的管道写端都关闭, 那么read会返回0
- 如果所有人的管道读端都关闭, 那么write会产生信号SIGPIPE, 默认终止进程

---

# 规则的测试与验证
## 空管道
- 阻塞模式下的情况
```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>

#define EXIT_ERROR(MSG) \
    do { \
        perror(MSG); \
        exit(EXIT_FAILURE); \
    } while(0)

int main() {
    int fd[2], ret;
//create pipe
    if (pipe(fd) < 0)
        EXIT_ERROR("pipe error");

    pid_t pid = fork();
    if (pid < 0)
        EXIT_ERROR("fork error");

//child process 1:
    if (0 == pid) {
        close(fd[0]);
        sleep(5);
        ret = write(fd[1], "hi", 2);
        if (ret < 0)
            EXIT_ERROR("write error");

        exit(EXIT_SUCCESS);
    }

    pid = fork();
    if (pid < 0)
        EXIT_ERROR("fork error");

//child process 2: count
    if (0 == pid) {
        int tick;
        for (tick = 0; tick < 5; tick++) {
            printf("tick\n");
            sleep(1);
        }
        exit(EXIT_SUCCESS);
    }

    close(fd[1]);
    char readbuf[10] = {0};
    ret = read(fd[0], readbuf, sizeof(readbuf));
    printf("read %d bytes, data: %s\n", ret, readbuf);

    return 0;
}

/************输出***********
[root@Server1 pipe]# ./a.out
tick
tick
tick
tick
tick
read 2 bytes, data: hi
 ***************************/
```
- 非阻塞模式下的情况
```
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/types.h>

#define EXIT_ERROR(MSG) \
    do { \
        perror(MSG); \
        exit(EXIT_FAILURE); \
    } while (0)

int main() {
    pid_t pid;
    int fd[2], ret, flags;
    char readbuf[10] = {0};

    if (pipe(fd) < 0)
        EXIT_ERROR("pipe error");

    pid = fork();
    if (pid < 0)
        EXIT_ERROR("fork error");

    if (0 == pid) {
        close(fd[0]);
        sleep(5);
        ret = write(fd[1], "hi", 2);
        if (ret < 0)
            EXIT_ERROR("write error");
        exit(EXIT_SUCCESS);
    }

    close(fd[1]);

    flags = fcntl(fd[0], F_GETFL); //get original flag
    fcntl(fd[0], F_SETFL, flags | O_NONBLOCK); //|= O_NONBLOCK

    ret = read(fd[0], readbuf, sizeof(readbuf));
    if (ret < 0)
        EXIT_ERROR("read error");

    printf("read %d bytes, data: %s\n", ret, readbuf);

    return 0;
}
/************输出***********
[root@Server1 pipe]# ./a.out
read error: Resource temporarily unavailable
 ***************************/

```
## 满管道
- 阻塞模式
```
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

#define EXIT_ERROR(MSG) \
    do { \
        perror(MSG); \
        exit(EXIT_SUCCESS); \
    } while(0)

int main() {
    int fd[2], ret, count = 0;

    if (pipe(fd) == -1)
        EXIT_ERROR("pipe error");

    while (1) {
        //write one byte
        ret = write(fd[1], "a", 1);
        count++;
        printf("%d\n", count);
        if (ret < 0) {
            EXIT_ERROR("write error");
        }
    }

    return 0;
}
/************输出***********
[root@Server1 pipe]# ./a.out
...
...
65532
65533
65534
65535
65536

 ***************************/
//确实阻塞了
```
- 非阻塞模式
```
include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>

#define EXIT_ERROR(MSG) \
    do { \
        perror(MSG); \
        exit(EXIT_FAILURE); \
    } while (0)

int main() {
    int fd[2], flags, ret, count = 0;

    if (pipe(fd) < 0)
        EXIT_ERROR("pipe error");

    flags = fcntl(fd[1], F_GETFL);
    fcntl(fd[1], F_SETFL, flags | O_NONBLOCK); // set nonblock

    while (1) {
        ret = write(fd[1], "a", 1);
        if (ret < 0) {
            perror("write error");
            break;
        }
        count++; //how many bytes have been successfully written
    }

    printf("pipe is now full\n");
    printf("%d bytes written\n", count);

    return 0;
}
/************输出***********
[root@Server1 pipe]# ./a.out
write error: Resource temporarily unavailable
pipe is now full
65536 bytes written
 ***************************/
// 说明非阻塞状态下, 管道满了的话write会立刻返回
```
## 管道的某一端被全部关闭
- 写端全关
```
nclude <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <stdlib.h>
#include <fcntl.h>

#define EXIT_ERROR(MSG) \
    do { \
        perror(MSG); \
        exit(EXIT_FAILURE); \
    } while (0)

int main() {
    int fd[2], ret;
    pid_t pid;
    char buf[10] = {0};

    if (pipe(fd) < 0)
        EXIT_ERROR("pipe error");

    pid = fork();
    if (pid < 0)
        EXIT_ERROR("fork error");

    if (pid == 0) {
        close(fd[1]);
        exit(EXIT_SUCCESS);
    }

    close(fd[1]);
    ret = read(fd[0], buf, sizeof(buf));
    printf("%d bytes read\n", ret);

    return 0;
}
/************输出***********
[root@Server1 pipe]# ./a.out
0 bytes read
 ***************************/
//在写端全关的情况下, 读并不会出错, 只是认为读到结束了
```
- 读端全关
```
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/types.h>
#include <signal.h>

#define ERR_EXIT(MSG) \
    do { \
        perror(MSG); \
        exit(EXIT_FAILURE); \
    } while (0)

void sighandler(int signal) {
    printf("signal %d caught\n", signal);
}

int main() {
    int fd[2], ret;
    pid_t pid;

    if (signal(SIGPIPE, sighandler) == SIG_ERR)
        ERR_EXIT("signal error");

    if (pipe(fd) < 0)
        ERR_EXIT("pipe error");

    pid = fork();
    if (pid < 0)
        ERR_EXIT("fork error");

    if (0 == pid) {
        close(fd[0]);
        exit(EXIT_SUCCESS);
    }

    close(fd[0]);
    sleep(1);
    ret = write(fd[1], "hi", 2);
    if (ret < 0)
        ERR_EXIT("write error");
    return 0;
}
/************输出***********
[root@Server1 pipe]# ./a.out
signal 13 caught
write error: Broken pipe
 ***************************/
//上面的SIGPIPE信号被捕捉了, 因此进程没有终止, 如果没有用signal函数来处理信号的话, 是看不到broken pipe的error的
```
## 写操作的原子性
- 阻塞, 小于PIPE_BUF
```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

#define ERR_EXIT(MSG) \
    do { \
        perror(MSG); \
        exit(EXIT_FAILURE); \
    } while (0)
#define CAP 65536
#define BUF 4096

int main() {
    int fd[2], ret, total = 10;
    pid_t pid;

    if (pipe(fd) < 0)
        ERR_EXIT("pipe error");

    pid = fork();
    if (pid < 0)
        ERR_EXIT("fork error");

    if (0 == pid) {
        close(fd[0]);
        char writebuf[CAP] = {'a'};
        ret = write(fd[1], writebuf, CAP - 1024);
        if (ret < 0)
            ERR_EXIT("write error");

        printf("child trying to write\n");
        ret = write(fd[1], writebuf, BUF - 100);
        if (ret < 0)
            ERR_EXIT("write error");
        printf("done writing\n");
    }

    close(fd[1]);

    wait(NULL);

    return 0;
}
/************输出***********
[root@Server1 pipe]# ./a.out
child trying to write
^C
 ***************************/
// 管道的最大容量, 前面的栗子里面已经测试过了, 是65536
// 根据man 7 pipe所看到的, 可以知道PIPE_BUF的值是4096
// 由于系统需要保证写入的原子性, 因此需要阻塞直到有足够空间让它写
```
- 阻塞, 大于PIPE_BUF
```

```
## 读操作的原子性

# 其他一些思考
- 在阻塞模式下, 如果进程A希望向管道里写小于PIPE_BUF的内容, 由于管道容量不够了, 写不下, 同时进程B每秒写100字节, 进程C每秒读取100字节, 那么A进程是否会永远等待下去呢
- 要是我不关闭读端进行写操作呢

[1]:https://www.ibm.com/developerworks/cn/linux/l-ipc/part1/#ibm-pcon
[2]:http://www.cnblogs.com/mickole/p/3192461.html
[3]:http://www.gnu.org/software/libc/manual/html_node/Pipe-Atomicity.html


